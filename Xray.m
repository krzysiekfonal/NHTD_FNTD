function [W, H,res,K] = Xray(M,r,type,A_init)

% FastConicalHull - Fast Conical Hull Algorithm for Near-separable 
% Non-negative Matrix Factorization
% 
% a.k.a. XRAY
%
% *** Description ***
% It recursively extracts r columns of the input matrix M:  at each step, 
% it selects a column of M corresponding to an extreme ray of the cone 
% generated by the columns of M, and then projects all the columns of M 
% on the cone generated by the columns of M extracted so far. 
%
% This is our implementation of XRAY(max) from A. Kumar, V. Sindhwani, and 
% P. Kambadur, Fast Conical Hull Algorithms for Near-separable Non-negative 
% Matrix Factorization, International Conference on Machine Learning, 2013 
% (ICML '13) (see also arXiv:1210.1190). 
% 
%
% ****** Input ******
% M = WH + N : a noisy separable matrix, that is, W >=0, H = [I,H']P where 
%              I is the identity matrix, H'>= 0, P is a permutation matrix, 
%              and N is sufficiently small. 
% r          : number of columns to be extracted. 
% type       : select the way o findig extreme ray
% ****** Output ******
% K        : index set of the extracted columns corresponding to extreme
%            rays of cone(M)
% H        : optimal weights = argmin_{X >= 0} ||M-M(:,K)H||_F
% res      : residiual error

if nargin==2
    type=1;
end

[m,n] = size(M); 
R = M; % residual 
p = ones(m,1); % as suggested in arXiv:1210.1190
K = []; 
Mobj = M;
nM = norm(M,'fro'); 
k = 1; 
%predefinition of i an j
i=[];
j=[];
res(1)=1;
%while k <= r && norm(R,'fro')/nM > 1e-6

if nargin==4
   %X = fast_hals_inner(A_hat,Y,X,J,tol,k_inner);
    MA = A_init;
    H = nnlsHALSupdt(M,MA); 
    W=MA;
end

while k <= r  
   
    if nargin==4 
        break; 
    end
    
    % Extract an extreme ray, diffrent type
    switch type
        case 1
            
            % standard (1) rand
            normR = sum(R.^2); 
            iR = find(normR > 0); 
            i = iR(randi([1 length(iR)])); 
            [~,j] = max(  (R(:,i)'*Mobj)./(p'*abs(Mobj)+1e-16)  ); 
                        
        case 2
        
            % standard (1) max
            normR = sum(R.^2); 
            [~,i] = max(normR); 
            [~,j] = max(  (R(:,i)'*Mobj)./(p'*abs(Mobj)+1e-16)  ); 
        
        case 3
            % dist (4)
            normR = sum(max(0,(R'*Mobj)).^2); 
            [~,i] = max(normR); 
            [~,j] = max(  (R(:,i)'*Mobj)./(p'*abs(Mobj)+1e-16)  ); 
            
        case 4
            % A greedy variant (5)    
            normR = sum(max(0,R'*Mobj).^2); 
            normX=sum(Mobj.^2);
            [~,j] = max( (normR.^2)./((normX.^2)+1e-16)  ); 
    end
    
    K = [K j]; 
    
    
    
%     Mobj(:,j) = 0;  
%     % Update residual 
%     if k == 1
%         H = nnlsHALSupdt(M,M(:,K)); 
%     else
%         H(:,j) = 0; 
%         h = zeros(1,n); h(j) = 1; 
%         H = [H; h]; 
%         H = nnlsHALSupdt(M,M(:,K),H); 
%     end
%     
%     W=M(:,K);
    

    MA = Mobj(:,K);
      
    H = fast_hals_inner(MA,M,rand(size(MA,2),size(M,2)),1e-5,200);
  %  H = nnlsHALSupdt(M,MA); 
    R = M - MA*H; 
    W = MA;
    % !Warning! R should not be computed explicitely in the sparse case.
    % We do it here for simplicity but this version is impractical for
    % large-scale sparse datasets (such as document datasets); but 
    % see arXiv:1210.1190. 
    res(k)=norm(M- W*H,'fro')/norm(M,'fro');
    k = k+1; 
end

end % of function FastConicalHull

%{

function [W, H,K] = FastConicalHull(M,r,type,H_on)

% FastConicalHull - Fast Conical Hull Algorithm for Near-separable 
% Non-negative Matrix Factorization
% 
% a.k.a. XRAY (max variant). 
%
% *** Description ***
% It recursively extracts r columns of the input matrix M:  at each step, 
% it selects a column of M corresponding to an extreme ray of the cone 
% generated by the columns of M, and then projects all the columns of M 
% on the cone generated by the columns of M extracted so far. 
%
% This is our implementation of XRAY(max) from A. Kumar, V. Sindhwani, and 
% P. Kambadur, Fast Conical Hull Algorithms for Near-separable Non-negative 
% Matrix Factorization, International Conference on Machine Learning, 2013 
% (ICML '13) (see also arXiv:1210.1190). 
% 
% K = FastConicalHull(M,r) 
%
% ****** Input ******
% M = WH + N : a noisy separable matrix, that is, W >=0, H = [I,H']P where 
%              I is the identity matrix, H'>= 0, P is a permutation matrix, 
%              and N is sufficiently small. 
% r          : number of columns to be extracted. 
% type       : select the way o findig extreme ray
% ****** Output ******
% K        : index set of the extracted columns corresponding to extreme
%            rays of cone(M)
% H        : optimal weights = argmin_{X >= 0} ||M-M(:,K)H||_F
% res      : residiual error

switch nargin
    case 4
    H=0;    
    case 3 
    H_on=1; 
    case 2
    H_on=1;
    type=1;
end

[m,n] = size(M); 
R = M; % residual 
p = ones(m,1); % as suggested in arXiv:1210.1190
K = []; 
Mobj = M; 
nM = norm(M,'fro'); 
k = 1; 
%predefinition of i an j
i=[];
j=[];
res(1)=1;
%while k <= r && norm(R,'fro')/nM > 1e-6
while k <= r    
    % Extract an extreme ray, diffrent types

    switch type
        case 1
            
            % standard (1) rand
            normR = sum(R.^2); 
            iR = find(normR > 0); 
            i = iR(randi([1 length(iR)])); 
            [~,j] = max(  (R(:,i)'*Mobj)./(p'*abs(Mobj)+1e-16)  ); 
                        
        case 2
        
            % standard (1) max
            normR = sum(R.^2); 
            [~,i] = max(normR); 
            [~,j] = max(  (R(:,i)'*Mobj)./(p'*abs(Mobj)+1e-16)  ); 
        
        case 3
            % dist (4)
            normR = sum(max(0,(R'*Mobj)).^2); 
            [~,i] = max(normR); 
            [~,j] = max(  (R(:,i)'*Mobj)./(p'*abs(Mobj)+1e-16)  ); 
            
        case 4
            % A greedy variant (5)    
            normR = sum(max(0,R'*Mobj).^2); 
            normX=sum(Mobj.^2);
            [~,j] = max( (normR.^2)./((normX.^2)+1e-16)  ); 
    end
    
    K = [K j]; 
    
    

  
%     Mobj(:,j) = 0;  
%     % Update residual 
%     if k == 1
%         H = nnlsHALSupdt(M,M(:,K)); 
%     else
%         H(:,j) = 0; 
%         h = zeros(1,n); h(j) = 1; 
%         H = [H; h]; 
%         H = nnlsHALSupdt(M,M(:,K),H); 
%     end
%     
%     W=M(:,K);
  MA = Mobj(:,K);
  W = MA;
  
if H_on==1
    
    H = nnlsHALSupdt(M,MA); 
    R = M - MA*H; 
  
    % !Warning! R should not be computed explicitely in the sparse case.
    % We do it here for simplicity but this version is impractical for
    % large-scale sparse datasets (such as document datasets); but 
    % see arXiv:1210.1190. 
    res(k)=norm(M- W*H,'fro')/norm(M,'fro');
end
    k = k+1; 
end

end % of function FastConicalHull
%}
